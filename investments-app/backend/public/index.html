<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Investment Tracker</title>
  <!-- Simple dark theme styling -->
  <style>
    /*
      Use CSS variables to support light and dark themes.  The default
      variable values implement the dark theme.  A .light-theme class on
      the root element overrides these variables for light mode.
    */
    :root {
      /*
        Colour palette definitions.  These values were chosen to improve
        contrast and provide a more modern look.  They are parameterised
        so that switching themes simply overrides the variables.
      */
      --bg-color: #121212;
      --card-bg-color: #1f2937; /* deep blue–grey */
      --text-color: #e5e7eb;   /* light grey */
      --primary-color: #3b82f6; /* sky blue */
      --primary-hover: #2563eb; /* darker blue on hover */
      --delete-color: #ef4444; /* soft red */
      --delete-hover: #dc2626; /* darker red */
      --border-color: #374151; /* slate */
      --heading-color: #60a5fa; /* lighter blue for headings */
      --row-alt-color: #1e293b; /* alternate row background */
      --row-hover-color: #334155; /* hover row background */
    }
    .light-theme {
      --bg-color: #f3f4f6;
      --card-bg-color: #ffffff;
      --text-color: #374151;
      --primary-color: #2563eb;
      --primary-hover: #1d4ed8;
      --delete-color: #dc2626;
      --delete-hover: #b91c1c;
      --border-color: #e5e7eb;
      --heading-color: #2563eb;
      --row-alt-color: #f9fafb;
      --row-hover-color: #e5e7eb;
    }
    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: Arial, Helvetica, sans-serif;
      margin: 0;
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      color: var(--heading-color);
      margin-top: 0;
    }
    .card {
      background-color: var(--card-bg-color);
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    label {
      display: block;
      margin-bottom: 4px;
    }
    input, select, button {
      width: 100%;
      padding: 8px;
      margin-bottom: 12px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background-color: var(--card-bg-color);
      color: var(--text-color);
    }
    button {
      cursor: pointer;
      background-color: var(--primary-color);
      border: none;
      color: #ffffff;
      transition: background-color 0.2s;
    }
    button:hover {
      background-color: var(--primary-hover);
    }

    /* Special styling for the theme toggle button.  It is a compact
       circular button displaying a sun or moon emoji depending on the
       current theme. */
    .theme-toggle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      padding: 0;
      margin-bottom: 20px;
      background-color: var(--card-bg-color);
      color: var(--primary-color);
      border: 1px solid var(--border-color);
      transition: background-color 0.2s, color 0.2s;
    }
    .theme-toggle:hover {
      background-color: var(--row-hover-color);
    }
    /* Distinct styling for delete buttons in the investment table */
    .delete-btn {
      background-color: var(--delete-color);
      border: none;
    }
    .delete-btn:hover {
      background-color: var(--delete-hover);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
    }
    th {
      color: var(--heading-color);
    }

    /* Alternate row colours and hover states for better readability */
    tbody tr:nth-child(even) {
      background-color: var(--row-alt-color);
    }
    tbody tr:hover {
      background-color: var(--row-hover-color);
    }

    thead tr {
      background-color: var(--card-bg-color);
    }
    .table-wrapper {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .section-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    .col {
      flex: 1 1 300px;
    }
    .progress-bar {
      background-color: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
      height: 20px;
      margin-top: 8px;
    }
    .progress-bar-fill {
      background-color: var(--primary-color);
      height: 100%;
      width: 0;
      transition: width 0.3s;
    }
    .chart-container {
      position: relative;
      width: 100%;
      height: 400px;
    }
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    .pagination button {
      width: auto;
      padding: 6px 12px;
    }
    
    /* Loading animation styles */
    .loading-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border-color);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s ease-in-out infinite;
      margin-right: 8px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .prediction-button {
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 140px;
    }
    
    .prediction-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    @media (max-width: 900px) {
      .container {
        padding: 12px;
      }
      .row {
        flex-direction: column;
      }
      .col {
        flex: 1 1 100%;
      }
      .card {
        padding: 14px;
      }
      input, select, button {
        font-size: 16px;
      }
      .pagination {
        flex-wrap: wrap;
      }
      .chart-container {
        height: 280px;
      }
      table {
        min-width: 620px;
      }
    }
  </style>
  <!-- Load React and other dependencies from CDNs -->
  <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script crossorigin src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- SheetJS for Excel import/export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!-- Application code written in JSX and compiled by Babel in the browser. -->
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Component to add a new investment
    function InvestmentForm({ currencies, onAdd, fundOptions = [], platformOptions = [] }) {
      /*
        The investment form allows the user to add a new investment.  In addition
        to specifying the amount, currency and date, the user can either pick
        from an existing fund/asset or platform or type a new one.  The
        `fundOptions` and `platformOptions` props are arrays of strings
        containing the unique values currently in the system.  They are used
        to populate HTML datalists so the user can select a previously used
        value or enter a new one.  The currency list comes from the rates
        endpoint.  Default values for fundOptions and platformOptions ensure
        the component works even when no options are provided.
      */
      const [form, setForm] = useState({
        unitPrice: '',
        units: '',
        currency: currencies && currencies.length > 0 ? currencies[0] : 'RON',
        fund: '',
        platform: '',
        date: new Date().toISOString().substr(0, 10)
      });

      useEffect(() => {
        if (currencies && currencies.length > 0) {
          setForm((prev) => ({ ...prev, currency: prev.currency || currencies[0] }));
        }
      }, [currencies]);

      const handleChange = (e) => {
        const { name, value } = e.target;
        setForm({ ...form, [name]: value });
      };

      const handleSubmit = (e) => {
        e.preventDefault();
        const price = parseFloat(form.unitPrice);
        const units = parseFloat(form.units);
        // Require both price and units to compute amount
        if (!isNaN(price) && !isNaN(units) && units >= 0 && price >= 0) {
          onAdd({ unitPrice: price, units: units, currency: form.currency, fund: form.fund || 'Unknown', platform: form.platform || 'Unknown', date: form.date });
          // reset form
          setForm({ ...form, unitPrice: '', units: '', fund: '', platform: '' });
        }
      };

      return (
        <div className="card">
          <h2>Add Investment</h2>
          <form onSubmit={handleSubmit}>
            <label>Unit Price</label>
            <input type="number" step="0.01" name="unitPrice" value={form.unitPrice} onChange={handleChange} required />
            <label>Units</label>
            <input type="number" step="0.0001" name="units" value={form.units} onChange={handleChange} required />
            {/* Display calculated amount for user feedback */}
            {form.unitPrice && form.units && !isNaN(parseFloat(form.unitPrice)) && !isNaN(parseFloat(form.units)) && (
              <div style={{ marginBottom: '12px' }}>
                <strong>Total Amount:</strong> {(parseFloat(form.unitPrice) * parseFloat(form.units)).toFixed(2)}
              </div>
            )}
            <label>Currency</label>
            <select name="currency" value={form.currency} onChange={handleChange}>
              {currencies && currencies.map((c) => (
                <option key={c} value={c}>{c}</option>
              ))}
            </select>
            <label>Fund/Asset</label>
            {/*
              Use a datalist to provide autocomplete suggestions for existing
              funds/assets.  The user can still type any value they like,
              including one not in the list.  Each datalist must have a
              unique id.  We use `fundList` and `platformList` here.
            */}
            <input type="text" name="fund" list="fundList" value={form.fund} onChange={handleChange} placeholder="e.g. Stock XYZ" />
            <datalist id="fundList">
              {fundOptions.map((opt) => (
                <option key={opt} value={opt} />
              ))}
            </datalist>
            <label>Platform</label>
            <input type="text" name="platform" list="platformList" value={form.platform} onChange={handleChange} placeholder="e.g. Broker ABC" />
            <datalist id="platformList">
              {platformOptions.map((opt) => (
                <option key={opt} value={opt} />
              ))}
            </datalist>
            <label>Date</label>
            <input type="date" name="date" value={form.date} onChange={handleChange} />
            <button type="submit">Add</button>
          </form>
        </div>
      );
    }

    // Component to sell units of an existing investment.  The user
    // specifies the fund/asset, platform, number of units to sell and the
    // sale price per unit.  Negative units are posted to the backend
    // through the same endpoint as purchases.  Currency is selected
    // separately to support multi‑currency portfolios.  A datalist
    // provides existing fund and platform suggestions.
    function SellForm({ currencies, onSell, fundOptions = [], platformOptions = [] }) {
      const [form, setForm] = useState({
        unitPrice: '',
        units: '',
        currency: currencies && currencies.length > 0 ? currencies[0] : 'RON',
        fund: '',
        platform: '',
        date: new Date().toISOString().substr(0, 10),
      });
      useEffect(() => {
        if (currencies && currencies.length > 0) {
          setForm((prev) => ({ ...prev, currency: prev.currency || currencies[0] }));
        }
      }, [currencies]);
      const handleChange = (e) => {
        const { name, value } = e.target;
        setForm({ ...form, [name]: value });
      };
      const handleSubmit = (e) => {
        e.preventDefault();
        const price = parseFloat(form.unitPrice);
        const units = parseFloat(form.units);
        // Units must be positive for input; we will send negative value
        if (!isNaN(price) && price >= 0 && !isNaN(units) && units > 0) {
          onSell({ unitPrice: price, units: -Math.abs(units), currency: form.currency, fund: form.fund || 'Unknown', platform: form.platform || 'Unknown', date: form.date });
          setForm({ ...form, unitPrice: '', units: '', fund: '', platform: '' });
        }
      };
      return (
        <div className="card">
          <h2>Sell Units</h2>
          <form onSubmit={handleSubmit}>
            <label>Unit Price</label>
            <input type="number" step="0.01" name="unitPrice" value={form.unitPrice} onChange={handleChange} required />
            <label>Units to Sell</label>
            <input type="number" step="0.0001" name="units" value={form.units} onChange={handleChange} required />
            {form.unitPrice && form.units && !isNaN(parseFloat(form.unitPrice)) && !isNaN(parseFloat(form.units)) && (
              <div style={{ marginBottom: '12px' }}>
                <strong>Total Sale Amount:</strong> {(-parseFloat(form.unitPrice) * parseFloat(form.units)).toFixed(2)}
              </div>
            )}
            <label>Currency</label>
            <select name="currency" value={form.currency} onChange={handleChange}>
              {currencies && currencies.map((c) => (
                <option key={c} value={c}>{c}</option>
              ))}
            </select>
            <label>Fund/Asset</label>
            <input type="text" name="fund" list="fundListSell" value={form.fund} onChange={handleChange} placeholder="Choose asset" />
            <datalist id="fundListSell">
              {fundOptions.map((opt) => (
                <option key={opt} value={opt} />
              ))}
            </datalist>
            <label>Platform</label>
            <input type="text" name="platform" list="platformListSell" value={form.platform} onChange={handleChange} placeholder="Choose platform" />
            <datalist id="platformListSell">
              {platformOptions.map((opt) => (
                <option key={opt} value={opt} />
              ))}
            </datalist>
            <label>Date</label>
            <input type="date" name="date" value={form.date} onChange={handleChange} />
            <button type="submit">Sell</button>
          </form>
        </div>
      );
    }

    // Component to set or update the investment objective
    function ObjectiveForm({ currencies, objective, onSave, prediction, isGeneratingPrediction, setIsGeneratingPrediction, setPrediction }) {
      const [targetAmount, setTargetAmount] = useState(objective ? objective.targetAmount : '');
      const [currency, setCurrency] = useState(objective ? objective.currency : (currencies && currencies[0]));
      useEffect(() => {
        if (objective) {
          setTargetAmount(objective.targetAmount);
          setCurrency(objective.currency);
        }
      }, [objective]);
      useEffect(() => {
        if (currencies && currencies.length > 0 && !currency) {
          setCurrency(currencies[0]);
        }
      }, [currencies]);
      const handleSubmit = (e) => {
        e.preventDefault();
        const amt = parseFloat(targetAmount);
        if (!isNaN(amt) && currency) {
          onSave({ targetAmount: amt, currency });
        }
      };
      return (
        <div className="card">
          <h2>Investment Objective</h2>
          <form onSubmit={handleSubmit}>
            <label>Target Amount</label>
            <input type="number" step="0.01" value={targetAmount} onChange={(e) => setTargetAmount(e.target.value)} required />
            <label>Currency</label>
            <select value={currency} onChange={(e) => setCurrency(e.target.value)}>
              {currencies && currencies.map((c) => (
                <option key={c} value={c}>{c}</option>
              ))}
            </select>
            <button type="submit">Save Objective</button>
          </form>
          {objective && (
            <div style={{ marginTop: '10px' }}>
              <strong>Current progress:</strong>
              <div className="progress-bar">
                <div className="progress-bar-fill" style={{ width: `${Math.min(100, (objective.currentTotal / objective.targetAmount) * 100)}%` }}></div>
              </div>
              <div style={{ marginTop: '4px' }}>
                {objective.currentTotal.toFixed(2)} / {objective.targetAmount.toFixed(2)} {objective.currency}
              </div>
            </div>
          )}
          {/* Display the predicted time to reach the goal if available */}
          {objective && (
            <div style={{ marginTop: '10px' }}>
              <strong>Predicted time to goal:</strong>
              <div style={{ marginTop: '4px' }}>
                {prediction ? prediction : 'No prediction available'}
              </div>
              <button 
                type="button" 
                className="prediction-button"
                disabled={isGeneratingPrediction}
                onClick={() => {
                  setIsGeneratingPrediction(true);
                  fetch('/api/prediction', { method: 'POST' })
                    .then(() => {
                      // Poll for the updated prediction
                      const pollInterval = setInterval(() => {
                        fetch('/api/prediction')
                          .then((res) => res.json())
                          .then((data) => {
                            // Stop loading when prediction is complete and different from current
                            if (data.prediction && data.prediction !== prediction && !data.isGenerating) {
                              setPrediction(data.prediction);
                              setIsGeneratingPrediction(false);
                              clearInterval(pollInterval);
                            }
                            // Also stop if generation is no longer in progress but we have a prediction
                            else if (data.prediction && !data.isGenerating) {
                              setPrediction(data.prediction);
                              setIsGeneratingPrediction(false);
                              clearInterval(pollInterval);
                            }
                          })
                          .catch(() => {
                            setIsGeneratingPrediction(false);
                            clearInterval(pollInterval);
                          });
                      }, 1000);
                      // Stop polling after 60 seconds (give more time for Ollama)
                      setTimeout(() => {
                        clearInterval(pollInterval);
                        setIsGeneratingPrediction(false);
                      }, 60000);
                    })
                    .catch(() => {
                      setIsGeneratingPrediction(false);
                    });
                }}
                style={{ marginTop: '8px' }}
              >
                {isGeneratingPrediction && <span className="loading-spinner"></span>}
                {isGeneratingPrediction ? 'Generating...' : 'Generate Prediction'}
              </button>
            </div>
          )}
        </div>
      );
    }

    // Component to display a chart summarising investments by fund or platform
    function InvestmentChart({ investments, rates, selectedCurrency, groupBy }) {
      const canvasRef = useRef(null);
      // Convert amounts into selected currency and group
      function convertAmount(amount, from, to) {
        if (!rates.rates[from] || !rates.rates[to]) return 0;
        const amountInRON = amount * rates.rates[from];
        return amountInRON / rates.rates[to];
      }
      // Compute current value per group (fund or platform).  When
      // grouping by fund we determine the latest price and total
      // units for each fund and multiply accordingly.  When grouping
      // by platform we aggregate units across funds per platform and
      // apply each fund's latest price.
      const dataMap = {};
      // Helper to convert a price from its original currency into the
      // selected currency via RON.
      function convertPrice(price, from, to) {
        if (!rates.rates[from] || !rates.rates[to]) return 0;
        const priceInRON = price * rates.rates[from];
        return priceInRON / rates.rates[to];
      }
      // Precompute latest price and currency for each fund.  This
      // mirrors the current value calculation by selecting the
      // investment with the most recent date (and highest timestamp
      // when dates are equal).
      const byFund = {};
      investments.forEach((inv) => {
        if (!byFund[inv.fund]) byFund[inv.fund] = [];
        byFund[inv.fund].push(inv);
      });
      const latestByFund = {};
      for (const fund in byFund) {
        const invs = byFund[fund];
        let latestInv = null;
        invs.forEach((inv) => {
          if (!latestInv) {
            latestInv = inv;
            return;
          }
          if (inv.date > latestInv.date) {
            latestInv = inv;
          } else if (inv.date === latestInv.date) {
            const currentTs = inv.timestamp != null ? inv.timestamp : parseInt(inv.id, 10);
            const bestTs = latestInv.timestamp != null ? latestInv.timestamp : parseInt(latestInv.id, 10);
            if (!isNaN(currentTs) && !isNaN(bestTs) && currentTs > bestTs) {
              latestInv = inv;
            }
          }
        });
        let latestPrice = null;
        let latestCur = null;
        if (latestInv) {
          if (typeof latestInv.unitPrice === 'number') {
            latestPrice = latestInv.unitPrice;
            latestCur = latestInv.currency;
          } else if (typeof latestInv.units === 'number' && latestInv.units !== 0) {
            latestPrice = latestInv.amount / latestInv.units;
            latestCur = latestInv.currency;
          }
        }
        latestByFund[fund] = latestPrice != null && latestCur != null ? { price: latestPrice, currency: latestCur } : null;
      }
      if (groupBy === 'fund') {
        // For each fund compute total units and multiply by latest price
        for (const fund in byFund) {
          const invs = byFund[fund];
          const latest = latestByFund[fund];
          if (!latest) {
            // Fallback: sum converted amounts
            let sum = 0;
            invs.forEach((inv) => {
              sum += convertAmount(inv.amount, inv.currency, selectedCurrency);
            });
            dataMap[fund] = sum;
            continue;
          }
          let totalUnits = 0;
          invs.forEach((inv) => {
            if (typeof inv.units === 'number') {
              totalUnits += inv.units;
            } else if (typeof inv.unitPrice === 'number' && inv.unitPrice !== 0) {
              totalUnits += inv.amount / inv.unitPrice;
            } else {
              // Unknown units: convert amount to latest currency then divide by latest price
              const conv = convertAmount(inv.amount, inv.currency, latest.currency);
              totalUnits += conv / latest.price;
            }
          });
          const valueInLatest = totalUnits * latest.price;
          const valueInSelected = convertAmount(valueInLatest, latest.currency, selectedCurrency);
          dataMap[fund] = valueInSelected;
        }
      } else {
        // groupBy === 'platform'
        // Accumulate units per platform and fund
        const unitsByPlatform = {};
        investments.forEach((inv) => {
          const platform = inv.platform;
          if (!unitsByPlatform[platform]) unitsByPlatform[platform] = {};
          if (!unitsByPlatform[platform][inv.fund]) unitsByPlatform[platform][inv.fund] = 0;
          let units = 0;
          if (typeof inv.units === 'number') {
            units = inv.units;
          } else if (typeof inv.unitPrice === 'number' && inv.unitPrice !== 0) {
            units = inv.amount / inv.unitPrice;
          } else {
            // Derive units using latest price of the fund
            const latest = latestByFund[inv.fund];
            if (latest) {
              const conv = convertAmount(inv.amount, inv.currency, latest.currency);
              units = conv / latest.price;
            }
          }
          unitsByPlatform[platform][inv.fund] += units;
        });
        // For each platform compute total value across funds
        for (const platform in unitsByPlatform) {
          let sum = 0;
          const fundsMap = unitsByPlatform[platform];
          for (const fund in fundsMap) {
            const units = fundsMap[fund];
            const latest = latestByFund[fund];
            if (latest) {
              const valueInLatest = units * latest.price;
              const valueInSelected = convertAmount(valueInLatest, latest.currency, selectedCurrency);
              sum += valueInSelected;
            }
          }
          dataMap[platform] = sum;
        }
      }
      const labels = Object.keys(dataMap);
      const values = labels.map((l) => dataMap[l]);
      // Colour palette for charts
      const colours = [
        '#bb86fc', '#03dac6', '#ffb74d', '#81c784', '#64b5f6', '#e57373', '#aed581', '#9575cd', '#4db6ac', '#ba68c8'
      ];
      useEffect(() => {
        if (!canvasRef.current) return;
        // Destroy previous chart if any
        if (canvasRef.current.chart) {
          canvasRef.current.chart.destroy();
        }
        const ctx = canvasRef.current.getContext('2d');
        canvasRef.current.chart = new Chart(ctx, {
          type: 'doughnut',
          data: {
            labels: labels,
            datasets: [
              {
                data: values,
                backgroundColor: labels.map((_, i) => colours[i % colours.length]),
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  color: '#e0e0e0',
                },
              },
              title: {
                display: true,
                text: groupBy === 'fund' ? 'Portfolio by Fund' : 'Portfolio by Platform',
                color: '#90caf9',
              },
            },
          },
        });
      }, [investments, rates, selectedCurrency, groupBy]);
      return (
        <div className="card">
          <h2>Distribution Chart</h2>
          <div className="chart-container">
            <canvas ref={canvasRef}></canvas>
          </div>
        </div>
      );
    }

    // Component to show the evolution of a single asset over time.  It plots
    // the unit price of the selected asset (converted to the currently
    // selected currency) against the date of each transaction.  A line
    // chart is used with discrete points marking purchase moments.
    function AssetEvolutionChart({ investments, rates, selectedCurrency, selectedAsset }) {
      const canvasRef = useRef(null);
      // Helper to convert a price from its original currency into the
      // selected currency.  Rates are in RON; convert via RON.
      function convertPrice(price, from, to) {
        if (!rates.rates[from] || !rates.rates[to]) return 0;
        const priceInRON = price * rates.rates[from];
        return priceInRON / rates.rates[to];
      }
      // Build arrays of dates and values for the selected asset
      const assetInvs = investments
        .filter((inv) => inv.fund === selectedAsset)
        .sort((a, b) => (a.date < b.date ? -1 : 1));
      const labels = assetInvs.map((inv) => inv.date);
      // Array of converted prices for purchases (units >= 0)
      const values = [];
      // Array of converted prices for sales (units < 0).  A null is used
      // for non‑sale positions to avoid drawing a connecting line.
      const sellValues = [];
      assetInvs.forEach((inv) => {
        let price = null;
        if (typeof inv.unitPrice === 'number') price = inv.unitPrice;
        else if (typeof inv.units === 'number' && inv.units !== 0) price = inv.amount / inv.units;
        else price = inv.amount;
        const convertedPrice = convertPrice(price, inv.currency, selectedCurrency);
        if (typeof inv.units === 'number' && inv.units < 0) {
          // Sale
          values.push(null);
          sellValues.push(convertedPrice);
        } else {
          values.push(convertedPrice);
          sellValues.push(null);
        }
      });
      useEffect(() => {
        if (!canvasRef.current) return;
        if (canvasRef.current.chart) {
          canvasRef.current.chart.destroy();
        }
        const ctx = canvasRef.current.getContext('2d');
        const rootStyles = getComputedStyle(document.documentElement);
        const headingColor = rootStyles.getPropertyValue('--heading-color').trim();
        const textColor = rootStyles.getPropertyValue('--text-color').trim();
        const borderColor = rootStyles.getPropertyValue('--border-color').trim();
        const sellColor = rootStyles.getPropertyValue('--delete-color').trim();
        canvasRef.current.chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              // Purchases dataset
              {
                label: `${selectedAsset} Buy`,
                data: values,
                borderColor: headingColor,
                backgroundColor: `${headingColor}33`,
                tension: 0.1,
                fill: true,
                pointRadius: 4,
                pointBackgroundColor: headingColor,
                pointBorderColor: headingColor,
              },
              // Sales dataset (draw only points, no line)
              {
                label: `${selectedAsset} Sell`,
                data: sellValues,
                borderColor: sellColor,
                backgroundColor: sellColor,
                pointRadius: 5,
                pointStyle: 'triangle',
                showLine: false,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  color: textColor,
                },
              },
              title: {
                display: true,
                text: `Price Evolution for ${selectedAsset}`,
                color: headingColor,
              },
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Date',
                  color: textColor,
                },
                ticks: {
                  color: textColor,
                },
                grid: {
                  color: borderColor,
                },
              },
              y: {
                title: {
                  display: true,
                  text: `Price per unit (${selectedCurrency})`,
                  color: textColor,
                },
                ticks: {
                  color: textColor,
                },
                grid: {
                  color: borderColor,
                },
              },
            },
          },
        });
      }, [investments, rates, selectedCurrency, selectedAsset]);
      if (assetInvs.length === 0) {
        return (
          <div className="card">
            <h2>Asset Evolution</h2>
            <p>No data for the selected asset.</p>
          </div>
        );
      }
      return (
        <div className="card">
          <h2>Asset Evolution</h2>
          <div className="chart-container">
            <canvas ref={canvasRef}></canvas>
          </div>
        </div>
      );
    }

    // Main application component
    function App() {
      const [rates, setRates] = useState({ rates: {} });
      const [currencies, setCurrencies] = useState([]);
      const [investments, setInvestments] = useState([]);
      const [objective, setObjective] = useState(null);
      const [selectedCurrency, setSelectedCurrency] = useState('RON');
      const [groupBy, setGroupBy] = useState('fund');
      // Store the latest prediction returned from the backend.  This
      // string is updated whenever a new investment is added,
      // removed or the objective changes.  Initially it is null to
      // indicate that no prediction has been fetched yet.
      const [prediction, setPrediction] = useState(null);
      const [isGeneratingPrediction, setIsGeneratingPrediction] = useState(false);
      const [netWorthItems, setNetWorthItems] = useState([]);
      const [netWorthDirty, setNetWorthDirty] = useState(false);
      const [netWorthCurrency, setNetWorthCurrency] = useState('RON');
      const [milestones, setMilestones] = useState([]);
      const [milestonesDirty, setMilestonesDirty] = useState(false);
      const [milestonesCurrency, setMilestonesCurrency] = useState('RON');
      const [profitEntries, setProfitEntries] = useState([]);
      const [profitSettings, setProfitSettings] = useState({ minSalary: 4050, cassRate: 0.1, thresholds: [6, 12, 24], currency: 'RON' });
      const [profitDirty, setProfitDirty] = useState(false);
      const [profitCurrency, setProfitCurrency] = useState('RON');
      const [swrCurrency, setSwrCurrency] = useState('RON');

      // Helper to fetch the current prediction from the server.  The
      // endpoint returns an object with a `prediction` property.  If
      // the value is null we keep the existing state so that the UI
      // doesn't flash between "Calculating…" and "No prediction".
      const updatePrediction = () => {
        fetch('/api/prediction')
          .then((res) => res.json())
          .then((data) => {
            if (data && Object.prototype.hasOwnProperty.call(data, 'prediction')) {
              setPrediction(data.prediction);
            }
          })
          .catch(() => {
            // ignore errors silently
          });
      };

      // Fetch rates, investments and objective on mount
      useEffect(() => {
        fetch('/api/rates')
          .then((res) => res.json())
          .then((data) => {
            setRates(data);
            setCurrencies(Object.keys(data.rates).sort());
            // Default selected currency to RON if available
            if (data.rates['RON']) {
              setSelectedCurrency('RON');
              setNetWorthCurrency('RON');
              setMilestonesCurrency('RON');
              setProfitCurrency('RON');
              setSwrCurrency('RON');
            }
          });
        fetch('/api/investments')
          .then((res) => res.json())
          .then((data) => setInvestments(data));
        fetch('/api/objective')
          .then((res) => res.json())
          .then((data) => {
            if (data) setObjective(data);
          });
        fetch('/api/net-worth')
          .then((res) => res.json())
          .then((data) => {
            if (data && Array.isArray(data.manualItems)) {
              setNetWorthItems(data.manualItems);
            }
          })
          .catch(() => {
            // ignore errors silently
          });
        fetch('/api/milestones')
          .then((res) => res.json())
          .then((data) => {
            const list = Array.isArray(data) ? data : data && Array.isArray(data.milestones) ? data.milestones : [];
            setMilestones(list);
            if (data && typeof data.currency === 'string') {
              setMilestonesCurrency(data.currency);
            }
          })
          .catch(() => {
            // ignore errors silently
          });
        fetch('/api/profit')
          .then((res) => res.json())
          .then((data) => {
            if (data && Array.isArray(data.entries)) {
              setProfitEntries(data.entries);
            }
            if (data && data.settings) {
              setProfitSettings((prev) => ({
                ...prev,
                ...data.settings,
              }));
              if (typeof data.settings.currency === 'string') {
                setProfitCurrency(data.settings.currency);
              }
            }
          })
          .catch(() => {
            // ignore errors silently
          });
        // Load existing prediction if available
        updatePrediction();
      }, []);

      const handleAddInvestment = (inv) => {
        fetch('/api/investments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(inv),
        })
          .then((res) => res.json())
          .then((newInv) => {
            setInvestments((prev) => [...prev, newInv]);
          });
      };

      const handleSaveObjective = (obj) => {
        fetch('/api/objective', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(obj),
        })
          .then((res) => res.json())
          .then(() => {
            // Recalculate current total by requesting objective again
            fetch('/api/objective')
              .then((res) => res.json())
              .then((data) => setObjective(data));
          });
      };

      const saveNetWorth = (items) => {
        fetch('/api/net-worth', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ manualItems: items }),
        })
          .then((res) => res.json())
          .then((data) => {
            if (data && Array.isArray(data.manualItems)) {
              setNetWorthItems(data.manualItems);
              setNetWorthDirty(false);
            }
          });
      };

      const saveMilestones = (items) => {
        fetch('/api/milestones', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ milestones: items, currency: milestonesCurrency }),
        })
          .then((res) => res.json())
          .then((data) => {
            const list = Array.isArray(data) ? data : data && Array.isArray(data.milestones) ? data.milestones : [];
            setMilestones(list);
            if (data && typeof data.currency === 'string') {
              setMilestonesCurrency(data.currency);
            }
            setMilestonesDirty(false);
          });
      };

      const saveProfitTracker = (entries, settings) => {
        fetch('/api/profit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ entries, settings: { ...settings, currency: profitCurrency } }),
        })
          .then((res) => res.json())
          .then((data) => {
            if (data && Array.isArray(data.entries)) {
              setProfitEntries(data.entries);
            }
            if (data && data.settings) {
              setProfitSettings((prev) => ({ ...prev, ...data.settings }));
              if (typeof data.settings.currency === 'string') {
                setProfitCurrency(data.settings.currency);
              }
            }
            setProfitDirty(false);
          });
      };

      // Convert amount helper
      const convertAmount = (amount, from, to) => {
        if (!rates.rates[from] || !rates.rates[to]) return 0;
        const inRON = amount * rates.rates[from];
        return inRON / rates.rates[to];
      };
      const getCurrentValue = (targetCurrency) => {
        const byFund = {};
        investments.forEach((inv) => {
          if (!byFund[inv.fund]) byFund[inv.fund] = [];
          byFund[inv.fund].push(inv);
        });
        let total = 0;
        for (const fund in byFund) {
          const invs = byFund[fund];
          let latestInv = null;
          invs.forEach((inv) => {
            if (!latestInv) {
              latestInv = inv;
              return;
            }
            if (inv.date > latestInv.date) {
              latestInv = inv;
            } else if (inv.date === latestInv.date) {
              const currentTs = inv.timestamp != null ? inv.timestamp : parseInt(inv.id, 10);
              const bestTs = latestInv.timestamp != null ? latestInv.timestamp : parseInt(latestInv.id, 10);
              if (!isNaN(currentTs) && !isNaN(bestTs) && currentTs > bestTs) {
                latestInv = inv;
              }
            }
          });
          let latestPrice = null;
          let latestCurrency = null;
          if (latestInv) {
            if (typeof latestInv.unitPrice === 'number') {
              latestPrice = latestInv.unitPrice;
              latestCurrency = latestInv.currency;
            } else if (typeof latestInv.units === 'number' && latestInv.units > 0) {
              latestPrice = latestInv.amount / latestInv.units;
              latestCurrency = latestInv.currency;
            }
          }
          if (latestPrice == null || latestCurrency == null) {
            invs.forEach((inv) => {
              total += convertAmount(inv.amount, inv.currency, targetCurrency);
            });
            continue;
          }
          let totalUnits = 0;
          invs.forEach((inv) => {
            if (typeof inv.units === 'number') {
              totalUnits += inv.units;
            } else if (typeof inv.unitPrice === 'number') {
              totalUnits += inv.amount / inv.unitPrice;
            } else {
              const conv = convertAmount(inv.amount, inv.currency, latestCurrency);
              totalUnits += conv / latestPrice;
            }
          });
          const valueInLatest = latestPrice * totalUnits;
          const value = convertAmount(valueInLatest, latestCurrency, targetCurrency);
          total += value;
        }
        return total;
      };
      // Compute money invested and current portfolio value in the selected currency.
      // Sum only purchase amounts to compute invested total.  Sales have
      // negative units (and negative amounts) and should not reduce the
      // invested sum.
      const totalInvested = investments.reduce((sum, inv) => {
        // Determine if this entry represents a sale: negative units or negative amount
        const isSale = (typeof inv.units === 'number' && inv.units < 0) || inv.amount < 0;
        if (isSale) return sum;
        // Compute invested amount for purchases
        const investedAmount = (typeof inv.unitPrice === 'number' && typeof inv.units === 'number') ? inv.unitPrice * inv.units : inv.amount;
        return sum + convertAmount(investedAmount, inv.currency, selectedCurrency);
      }, 0);
      // Current portfolio value is the sum over each asset of (total units * latest unit price).
      const currentValue = getCurrentValue(selectedCurrency);

      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      const getManualTotals = (targetCurrency) => {
        return netWorthItems.reduce(
          (acc, item) => {
            const raw = typeof item.value === 'number' ? item.value : parseFloat(item.value);
            const value = isNaN(raw) ? 0 : convertAmount(raw, item.currency || targetCurrency, targetCurrency);
            if (item.type === 'liability') {
              acc.liabilities += value;
            } else {
              acc.assets += value;
            }
            if (typeof item.name === 'string' && item.name.toLowerCase().includes('retirement')) {
              acc.retirement += value;
            }
            return acc;
          },
          { assets: 0, liabilities: 0, retirement: 0 }
        );
      };

      const manualTotals = getManualTotals(netWorthCurrency);
      const netWorthCurrentValue = getCurrentValue(netWorthCurrency);
      const netWorthTotal = netWorthCurrentValue + manualTotals.assets - manualTotals.liabilities;

      const swrTotals = getManualTotals(swrCurrency);
      const swrCurrentValue = getCurrentValue(swrCurrency);
      const portfolioPlusRetirement = swrCurrentValue + swrTotals.retirement;
      const milestoneCurrentValue = getCurrentValue(milestonesCurrency);

      const avgMonthlyContribution = (() => {
        if (investments.length === 0) return 0;
        const now = new Date();
        const monthsBack = 12;
        const windowStart = new Date(now.getFullYear(), now.getMonth() - (monthsBack - 1), 1);
        const windowStartStr = formatDate(windowStart);
        let total = 0;
        investments.forEach((inv) => {
          if (!inv.date || inv.date < windowStartStr) return;
          const isSale = (typeof inv.units === 'number' && inv.units < 0) || inv.amount < 0;
          if (isSale) return;
          const investedAmount =
            typeof inv.unitPrice === 'number' && typeof inv.units === 'number'
              ? inv.unitPrice * inv.units
              : inv.amount;
          total += convertAmount(investedAmount, inv.currency, milestonesCurrency);
        });
        return total / monthsBack;
      })();

      const estimateMilestone = (target) => {
        const numericTarget = typeof target === 'number' ? target : parseFloat(target);
        if (!numericTarget || isNaN(numericTarget)) {
          return { status: '—', dateReached: '', estDate: '', monthsRemaining: null };
        }
        if (milestoneCurrentValue >= numericTarget) {
          return { status: 'Reached', dateReached: formatDate(new Date()), estDate: '', monthsRemaining: 0 };
        }
        if (avgMonthlyContribution <= 0) {
          return { status: 'No estimate', dateReached: '', estDate: '', monthsRemaining: null };
        }
        const remaining = numericTarget - milestoneCurrentValue;
        const months = Math.max(1, Math.ceil(remaining / avgMonthlyContribution));
        const est = new Date();
        est.setMonth(est.getMonth() + months);
        return { status: 'In progress', dateReached: '', estDate: formatDate(est), monthsRemaining: months };
      };

      const calcCassDue = (profit) => {
        const minSalary = typeof profitSettings.minSalary === 'number' ? profitSettings.minSalary : parseFloat(profitSettings.minSalary);
        const rate = typeof profitSettings.cassRate === 'number' ? profitSettings.cassRate : parseFloat(profitSettings.cassRate);
        const thresholds = Array.isArray(profitSettings.thresholds) && profitSettings.thresholds.length > 0 ? profitSettings.thresholds : [6, 12, 24];
        if (!minSalary || !rate || isNaN(minSalary) || isNaN(rate)) return 0;
        const sorted = [...thresholds].sort((a, b) => a - b);
        const t1 = minSalary * sorted[0];
        const t2 = minSalary * (sorted[1] || sorted[0]);
        const t3 = minSalary * (sorted[2] || sorted[1] || sorted[0]);
        if (profit < t1) return 0;
        if (profit < t2) return t1 * rate;
        if (profit < t3) return t2 * rate;
        return t3 * rate;
      };

      const profitByYear = profitEntries.reduce((acc, entry) => {
        const year = entry.date ? entry.date.slice(0, 4) : 'Unknown';
        const amount = typeof entry.amount === 'number' ? entry.amount : parseFloat(entry.amount);
        acc[year] = (acc[year] || 0) + (isNaN(amount) ? 0 : amount);
        return acc;
      }, {});
      const profitYears = Object.keys(profitByYear).sort();

      // Delete investment by id
      const handleDelete = (id) => {
        fetch('/api/investments/' + id, {
          method: 'DELETE',
        })
          .then((res) => {
            if (res.ok) {
              setInvestments((prev) => prev.filter((inv) => inv.id !== id));
            }
          });
      };

      // Sell units handler.  Posts a negative units entry to the
      // backend and updates local state upon success.  A sale is
      // treated like any other investment but with a negative unit
      // count which the server interprets as a sale.
      const handleSellInvestment = (sale) => {
        fetch('/api/investments', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(sale),
        })
          .then((res) => res.json())
          .then((newInv) => {
            setInvestments((prev) => [...prev, newInv]);
          });
      };

      const updateNetWorthItem = (id, patch) => {
        setNetWorthItems((prev) =>
          prev.map((item) => (item.id === id ? { ...item, ...patch } : item))
        );
        setNetWorthDirty(true);
      };

      const addNetWorthItem = () => {
        const id = `nw-${Date.now()}`;
        setNetWorthItems((prev) => [
          ...prev,
          { id, name: 'New Item', type: 'asset', value: 0, currency: netWorthCurrency || 'RON' },
        ]);
        setNetWorthDirty(true);
      };

      const removeNetWorthItem = (id) => {
        setNetWorthItems((prev) => prev.filter((item) => item.id !== id));
        setNetWorthDirty(true);
      };

      const updateMilestone = (id, patch) => {
        setMilestones((prev) => prev.map((m) => (m.id === id ? { ...m, ...patch } : m)));
        setMilestonesDirty(true);
      };

      const addMilestone = () => {
        const id = `ms-${Date.now()}`;
        setMilestones((prev) => [...prev, { id, target: 0, targetDate: '' }]);
        setMilestonesDirty(true);
      };

      const removeMilestone = (id) => {
        setMilestones((prev) => prev.filter((m) => m.id !== id));
        setMilestonesDirty(true);
      };

      const handleMilestonesCurrencyChange = (nextCurrency) => {
        if (!nextCurrency || nextCurrency === milestonesCurrency) return;
        setMilestones((prev) =>
          prev.map((m) => {
            const raw = typeof m.target === 'number' ? m.target : parseFloat(m.target);
            const converted = isNaN(raw) ? 0 : convertAmount(raw, milestonesCurrency, nextCurrency);
            return { ...m, target: converted };
          })
        );
        setMilestonesCurrency(nextCurrency);
        setMilestonesDirty(true);
      };

      const updateProfitEntry = (id, patch) => {
        setProfitEntries((prev) => prev.map((e) => (e.id === id ? { ...e, ...patch } : e)));
        setProfitDirty(true);
      };

      const addProfitEntry = () => {
        const id = `pf-${Date.now()}`;
        setProfitEntries((prev) => [...prev, { id, date: formatDate(new Date()), amount: 0, name: '', comment: '' }]);
        setProfitDirty(true);
      };

      const removeProfitEntry = (id) => {
        setProfitEntries((prev) => prev.filter((e) => e.id !== id));
        setProfitDirty(true);
      };

      const handleProfitCurrencyChange = (nextCurrency) => {
        if (!nextCurrency || nextCurrency === profitCurrency) return;
        setProfitEntries((prev) =>
          prev.map((e) => {
            const raw = typeof e.amount === 'number' ? e.amount : parseFloat(e.amount);
            const converted = isNaN(raw) ? 0 : convertAmount(raw, profitCurrency, nextCurrency);
            return { ...e, amount: converted };
          })
        );
        setProfitCurrency(nextCurrency);
        setProfitSettings((prev) => ({ ...prev, currency: nextCurrency }));
        setProfitDirty(true);
      };

      // Compute unique funds/assets and platforms for datalist inputs and filters
      const fundOptions = Array.from(new Set(investments.map((inv) => inv.fund))).filter((f) => f && f !== 'Unknown');
      const platformOptions = Array.from(new Set(investments.map((inv) => inv.platform))).filter((p) => p && p !== 'Unknown');

      // Asset options for evolution chart
      const assetOptions = Array.from(new Set(investments.map((inv) => inv.fund))).filter((f) => f && f !== 'Unknown');
      // Selected asset state; default to first available asset
      const [selectedAsset, setSelectedAsset] = useState(assetOptions.length > 0 ? assetOptions[0] : '');
      useEffect(() => {
        if (assetOptions.length > 0 && !assetOptions.includes(selectedAsset)) {
          setSelectedAsset(assetOptions[0]);
        }
      }, [assetOptions]);

      // Filter states for date range and fund
      const [startDateFilter, setStartDateFilter] = useState('');
      const [endDateFilter, setEndDateFilter] = useState('');
      const [fundFilter, setFundFilter] = useState('All');
      const [pageSize] = useState(5);
      const [currentPage, setCurrentPage] = useState(1);

      // Reset pagination when filters or investments change
      useEffect(() => {
        setCurrentPage(1);
      }, [startDateFilter, endDateFilter, fundFilter, investments]);

      // Compute filtered investments based on filters
      const filteredInvestments = investments.filter((inv) => {
        // Filter by fund if selected
        const fundMatches = fundFilter === 'All' || inv.fund === fundFilter;
        // Filter by start date
        const startMatches = !startDateFilter || inv.date >= startDateFilter;
        // Filter by end date
        const endMatches = !endDateFilter || inv.date <= endDateFilter;
        return fundMatches && startMatches && endMatches;
      });
      // Pagination
      const totalPages = Math.max(1, Math.ceil(filteredInvestments.length / pageSize));
      const startIdx = (currentPage - 1) * pageSize;
      const paginatedInvestments = filteredInvestments.slice(startIdx, startIdx + pageSize);

      // Theme state: dark (default) or light.  A state flag controls a
      // `light-theme` class on the body to switch CSS variables.  The
      // toggleTheme function flips the flag.
      const [isLightTheme, setIsLightTheme] = useState(false);
      useEffect(() => {
        if (isLightTheme) {
          document.body.classList.add('light-theme');
        } else {
          document.body.classList.remove('light-theme');
        }
      }, [isLightTheme]);
      const toggleTheme = () => setIsLightTheme((prev) => !prev);

      // Compute units by fund and platform.  Sales (negative units)
      // subtract from the total.  For entries without explicit units,
      // derive the units from amount and unitPrice when possible; if
      // neither is available, assume zero units for stats purposes.
      const statsRows = (() => {
        // Local helpers to convert amounts and prices to the selected currency
        function convertAmountLocal(amount, from, to) {
          if (!rates.rates[from] || !rates.rates[to]) return 0;
          const inRon = amount * rates.rates[from];
          return inRon / rates.rates[to];
        }
        function convertPriceLocal(price, from, to) {
          if (!rates.rates[from] || !rates.rates[to]) return 0;
          const priceInRon = price * rates.rates[from];
          return priceInRon / rates.rates[to];
        }
        // Precompute latest price and currency per fund
        const byFund = {};
        investments.forEach((inv) => {
          if (!byFund[inv.fund]) byFund[inv.fund] = [];
          byFund[inv.fund].push(inv);
        });
        const latestByFund = {};
        for (const fund in byFund) {
          const invs = byFund[fund];
          let latestInv = null;
          invs.forEach((inv) => {
            if (!latestInv) {
              latestInv = inv;
              return;
            }
            if (inv.date > latestInv.date) {
              latestInv = inv;
            } else if (inv.date === latestInv.date) {
              const currentTs = inv.timestamp != null ? inv.timestamp : parseInt(inv.id, 10);
              const bestTs = latestInv.timestamp != null ? latestInv.timestamp : parseInt(latestInv.id, 10);
              if (!isNaN(currentTs) && !isNaN(bestTs) && currentTs > bestTs) {
                latestInv = inv;
              }
            }
          });
          let price = null;
          let cur = null;
          if (latestInv) {
            if (typeof latestInv.unitPrice === 'number') {
              price = latestInv.unitPrice;
              cur = latestInv.currency;
            } else if (typeof latestInv.units === 'number' && latestInv.units !== 0) {
              price = latestInv.amount / latestInv.units;
              cur = latestInv.currency;
            }
          }
          latestByFund[fund] = price != null && cur != null ? { price, currency: cur } : null;
        }
        const map = {};
        investments.forEach((inv) => {
          const key = inv.fund + '|' + inv.platform;
          if (!map[key]) {
            map[key] = { fund: inv.fund, platform: inv.platform, units: 0, unitPrice: null };
          }
          let units = 0;
          if (typeof inv.units === 'number') {
            units = inv.units;
          } else if (typeof inv.unitPrice === 'number' && inv.unitPrice !== 0) {
            units = inv.amount / inv.unitPrice;
          } else {
            // derive units using latest price for the fund
            const latest = latestByFund[inv.fund];
            if (latest) {
              const conv = convertAmountLocal(inv.amount, inv.currency, latest.currency);
              units = conv / latest.price;
            }
          }
          map[key].units += units;
        });
        // Compute current unit price per fund in selected currency
        Object.values(map).forEach((row) => {
          const latest = latestByFund[row.fund];
          if (latest) {
            row.unitPrice = convertPriceLocal(latest.price, latest.currency, selectedCurrency);
          }
        });
        return Object.values(map);
      })();

      // Export current investments to a JSON file.  Creates a blob
      // containing the JSON and triggers a download.
      const exportJSON = () => {
        const dataStr = JSON.stringify(investments, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'investments.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };
      // Export current investments to an Excel file using SheetJS
      const exportExcel = () => {
        // Prepare a shallow copy without functions to avoid issues
        const data = investments.map((inv) => ({ ...inv }));
        const worksheet = XLSX.utils.json_to_sheet(data);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Investments');
        XLSX.writeFile(workbook, 'investments.xlsx');
      };
      // Import investments from a selected file (JSON or Excel)
      const handleFileImport = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const ext = file.name.split('.').pop().toLowerCase();
        const reader = new FileReader();
        reader.onload = (event) => {
          const contents = event.target.result;
          let imported = [];
          if (ext === 'json') {
            try {
              imported = JSON.parse(contents);
            } catch (err) {
              alert('Invalid JSON file');
              return;
            }
          } else if (ext === 'xls' || ext === 'xlsx') {
            const data = new Uint8Array(contents);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheet];
            imported = XLSX.utils.sheet_to_json(worksheet);
          } else {
            alert('Unsupported file type');
            return;
          }
          // Send imported investments to backend
          fetch('/api/import', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ investments: imported }),
          })
            .then((res) => res.json())
            .then((data) => {
              // Reload investments from server
              fetch('/api/investments')
                .then((res) => res.json())
                              .then((invData) => {
                setInvestments(invData);
              });
            });
        };
        if (ext === 'json') {
          reader.readAsText(file);
        } else {
          reader.readAsArrayBuffer(file);
        }
      };

      return (
        <div className="container">
          <h1>Investment Tracker</h1>
          {/* Theme toggle button: displays a sun when dark mode is active and a moon when light mode is active. */}
          <button className="theme-toggle" aria-label={isLightTheme ? 'Switch to dark mode' : 'Switch to light mode'} onClick={toggleTheme}>
            {isLightTheme ? '🌙' : '☀️'}
          </button>
          <div className="row">
            <div className="col">
              <InvestmentForm
                currencies={currencies}
                onAdd={handleAddInvestment}
                fundOptions={fundOptions}
                platformOptions={platformOptions}
              />
            </div>
            <div className="col">
              <SellForm
                currencies={currencies}
                onSell={handleSellInvestment}
                fundOptions={fundOptions}
                platformOptions={platformOptions}
              />
            </div>
            <div className="col">
              <ObjectiveForm 
                currencies={currencies} 
                objective={objective} 
                onSave={handleSaveObjective} 
                prediction={prediction}
                isGeneratingPrediction={isGeneratingPrediction}
                setIsGeneratingPrediction={setIsGeneratingPrediction}
                setPrediction={setPrediction}
              />
            </div>
          </div>
          {/* Units summary per fund and platform */}
          <div className="card">
            <h2>Units by Fund and Platform</h2>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Fund</th>
                  <th>Platform</th>
                  <th>Units</th>
                  <th>Current Unit Price ({selectedCurrency})</th>
                </tr>
              </thead>
              <tbody>
                {statsRows.map((row, idx) => (
                  <tr key={idx}>
                    <td>{row.fund}</td>
                    <td>{row.platform}</td>
                    <td>{row.units.toFixed(4)}</td>
                    <td>{row.unitPrice != null ? row.unitPrice.toFixed(2) : '—'}</td>
                  </tr>
                ))}
                {statsRows.length === 0 && (
                  <tr>
                    <td colSpan="4" style={{ textAlign: 'center' }}>No data</td>
                  </tr>
                )}
              </tbody>
              </table>
            </div>
          </div>
          {/* Import and export controls */}
          <div className="card">
            <h2>Import / Export</h2>
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px' }}>
              <button onClick={exportJSON}>Export JSON</button>
              <button onClick={exportExcel}>Export Excel</button>
              <input type="file" accept=".json,.xls,.xlsx" onChange={handleFileImport} />
            </div>
          </div>
          <div className="card">
            <h2>Your Investments</h2>
            {/* Filter controls */}
            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px', marginBottom: '10px' }}>
              <div style={{ flex: '1 1 150px' }}>
                <label>Start Date</label>
                <input type="date" value={startDateFilter} onChange={(e) => setStartDateFilter(e.target.value)} />
              </div>
              <div style={{ flex: '1 1 150px' }}>
                <label>End Date</label>
                <input type="date" value={endDateFilter} onChange={(e) => setEndDateFilter(e.target.value)} />
              </div>
              <div style={{ flex: '1 1 200px' }}>
                <label>Filter by Fund</label>
                <select value={fundFilter} onChange={(e) => setFundFilter(e.target.value)}>
                  <option value="All">All</option>
                  {fundOptions.map((f) => (
                    <option key={f} value={f}>{f}</option>
                  ))}
                </select>
              </div>
              <div style={{ flex: '1 1 200px' }}>
                <label>Display Currency</label>
                <select value={selectedCurrency} onChange={(e) => setSelectedCurrency(e.target.value)}>
                  {currencies.map((c) => (
                    <option key={c} value={c}>{c}</option>
                  ))}
                </select>
              </div>
            </div>
            <div style={{ marginTop: '10px', display: 'flex', flexWrap: 'wrap', gap: '20px' }}>
              <div><strong>Invested:</strong> {totalInvested.toFixed(2)} {selectedCurrency}</div>
              <div><strong>Current Value:</strong> {currentValue.toFixed(2)} {selectedCurrency}</div>
            </div>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Fund</th>
                  <th>Platform</th>
                  <th>Unit Price</th>
                  <th>Units</th>
                  <th>Amount</th>
                  <th>Currency</th>
                  <th>Value in {selectedCurrency}</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {paginatedInvestments.map((inv) => {
                  const unitPrice = typeof inv.unitPrice === 'number' ? inv.unitPrice : (typeof inv.units === 'number' && inv.units > 0 ? inv.amount / inv.units : null);
                    const units = typeof inv.units === 'number' ? inv.units : (typeof inv.unitPrice === 'number' && inv.unitPrice > 0 ? inv.amount / inv.unitPrice : null);
                  return (
                    <tr key={inv.id}>
                      <td>{inv.date}</td>
                      <td>{inv.fund}</td>
                      <td>{inv.platform}</td>
                      <td>{unitPrice != null ? unitPrice.toFixed(2) : '—'}</td>
                      <td>{units != null ? units.toFixed(4) : '—'}</td>
                      <td>{inv.amount.toFixed(2)}</td>
                      <td>{inv.currency}</td>
                      <td>{convertAmount(inv.amount, inv.currency, selectedCurrency).toFixed(2)}</td>
                      <td><button className="delete-btn" onClick={() => handleDelete(inv.id)}>Delete</button></td>
                    </tr>
                  );
                })}
                {paginatedInvestments.length === 0 && (
                  <tr>
                    <td colSpan="9" style={{ textAlign: 'center' }}>No investments found.</td>
                  </tr>
                )}
              </tbody>
              </table>
            </div>
            {/* Pagination controls */}
            <div className="pagination">
              <button onClick={() => setCurrentPage((p) => Math.max(1, p - 1))} disabled={currentPage === 1}>Previous</button>
              <span>Page {currentPage} of {totalPages}</span>
              <button onClick={() => setCurrentPage((p) => Math.min(totalPages, p + 1))} disabled={currentPage === totalPages}>Next</button>
            </div>
          </div>
          <div className="card">
            <h2>Chart Options</h2>
            <label>Group By</label>
            <select value={groupBy} onChange={(e) => setGroupBy(e.target.value)}>
              <option value="fund">Fund/Asset</option>
              <option value="platform">Platform</option>
            </select>
          </div>
          <InvestmentChart investments={filteredInvestments} rates={rates} selectedCurrency={selectedCurrency} groupBy={groupBy} />
          {/* Asset evolution controls and chart */}
          <div className="card">
            <h2>Asset Evolution Options</h2>
            <label>Select Asset</label>
            <select value={selectedAsset} onChange={(e) => setSelectedAsset(e.target.value)}>
              {assetOptions.map((asset) => (
                <option key={asset} value={asset}>{asset}</option>
              ))}
            </select>
          </div>
          <AssetEvolutionChart investments={investments} rates={rates} selectedCurrency={selectedCurrency} selectedAsset={selectedAsset} />
          <div className="card">
            <h2>Net Worth</h2>
            <div className="section-controls">
              <div>
                <label>Display Currency</label>
                <select value={netWorthCurrency} onChange={(e) => setNetWorthCurrency(e.target.value)}>
                  {currencies.map((c) => (
                    <option key={c} value={c}>{c}</option>
                  ))}
                </select>
              </div>
            </div>
            <div style={{ marginBottom: '10px' }}>
              <div><strong>Portfolio value:</strong> {netWorthCurrentValue.toFixed(2)} {netWorthCurrency}</div>
              <div><strong>Manual assets:</strong> {manualTotals.assets.toFixed(2)} {netWorthCurrency}</div>
              <div><strong>Manual liabilities:</strong> {manualTotals.liabilities.toFixed(2)} {netWorthCurrency}</div>
              <div><strong>Total net worth:</strong> {netWorthTotal.toFixed(2)} {netWorthCurrency}</div>
            </div>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Category</th>
                  <th>Type</th>
                  <th>Value</th>
                  <th>Currency</th>
                  <th>Value in {netWorthCurrency}</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {netWorthItems.map((item) => (
                  <tr key={item.id}>
                    <td>
                      <input
                        value={item.name || ''}
                        onChange={(e) => updateNetWorthItem(item.id, { name: e.target.value })}
                      />
                    </td>
                    <td>
                      <select
                        value={item.type || 'asset'}
                        onChange={(e) => updateNetWorthItem(item.id, { type: e.target.value })}
                      >
                        <option value="asset">Asset</option>
                        <option value="liability">Liability</option>
                      </select>
                    </td>
                    <td>
                      <input
                        type="number"
                        value={item.value}
                        onChange={(e) => {
                          const nextValue = parseFloat(e.target.value);
                          updateNetWorthItem(item.id, { value: isNaN(nextValue) ? 0 : nextValue });
                        }}
                      />
                    </td>
                    <td>
                      <select
                        value={item.currency || netWorthCurrency}
                        onChange={(e) => updateNetWorthItem(item.id, { currency: e.target.value })}
                      >
                        {currencies.map((c) => (
                          <option key={c} value={c}>{c}</option>
                        ))}
                      </select>
                    </td>
                    <td>
                      {(() => {
                        const raw = typeof item.value === 'number' ? item.value : parseFloat(item.value);
                        const valueInSelected = isNaN(raw)
                          ? 0
                          : convertAmount(raw, item.currency || netWorthCurrency, netWorthCurrency);
                        return Number.isFinite(valueInSelected) ? valueInSelected.toFixed(2) : '0.00';
                      })()}
                    </td>
                    <td>
                      <button className="delete-btn" onClick={() => removeNetWorthItem(item.id)}>Remove</button>
                    </td>
                  </tr>
                ))}
                {netWorthItems.length === 0 && (
                  <tr>
                    <td colSpan="6" style={{ textAlign: 'center' }}>No manual items yet.</td>
                  </tr>
                )}
              </tbody>
              </table>
            </div>
            <div style={{ display: 'flex', gap: '10px', marginTop: '10px', flexWrap: 'wrap' }}>
              <button onClick={addNetWorthItem}>Add Item</button>
              <button onClick={() => saveNetWorth(netWorthItems)} disabled={!netWorthDirty}>Save Net Worth</button>
            </div>
          </div>
          <div className="card">
            <h2>Milestones</h2>
            <div className="section-controls">
              <div>
                <label>Display Currency</label>
                <select value={milestonesCurrency} onChange={(e) => handleMilestonesCurrencyChange(e.target.value)}>
                  {currencies.map((c) => (
                    <option key={c} value={c}>{c}</option>
                  ))}
                </select>
              </div>
            </div>
            <div style={{ marginBottom: '10px' }}>
              <div><strong>Avg monthly contribution (last 12 months):</strong> {avgMonthlyContribution.toFixed(2)} {milestonesCurrency}</div>
              <div><strong>Current portfolio value:</strong> {milestoneCurrentValue.toFixed(2)} {milestonesCurrency}</div>
            </div>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Target ({milestonesCurrency})</th>
                  <th>Target Date</th>
                  <th>Status</th>
                  <th>Date Reached</th>
                  <th>EST</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {milestones.map((m) => {
                  const est = estimateMilestone(m.target);
                  const estLabel = est.estDate
                    ? est.monthsRemaining != null
                      ? `${est.estDate} (${est.monthsRemaining} mo)`
                      : est.estDate
                    : '—';
                  return (
                    <tr key={m.id}>
                      <td>
                        <input
                          type="number"
                          value={m.target}
                          onChange={(e) => {
                            const nextValue = parseFloat(e.target.value);
                            updateMilestone(m.id, { target: isNaN(nextValue) ? 0 : nextValue });
                          }}
                        />
                      </td>
                      <td>
                        <input
                          type="date"
                          value={m.targetDate || ''}
                          onChange={(e) => updateMilestone(m.id, { targetDate: e.target.value })}
                        />
                      </td>
                      <td>{est.status}</td>
                      <td>{est.dateReached || '—'}</td>
                      <td>{estLabel}</td>
                      <td>
                        <button className="delete-btn" onClick={() => removeMilestone(m.id)}>Remove</button>
                      </td>
                    </tr>
                  );
                })}
                {milestones.length === 0 && (
                  <tr>
                    <td colSpan="6" style={{ textAlign: 'center' }}>No milestones yet.</td>
                  </tr>
                )}
              </tbody>
              </table>
            </div>
            <div style={{ display: 'flex', gap: '10px', marginTop: '10px', flexWrap: 'wrap' }}>
              <button onClick={addMilestone}>Add Milestone</button>
              <button onClick={() => saveMilestones(milestones)} disabled={!milestonesDirty}>Save Milestones</button>
            </div>
          </div>
          <div className="card">
            <h2>Profit Tracker</h2>
            <div className="section-controls">
              <div>
                <label>Display Currency</label>
                <select value={profitCurrency} onChange={(e) => handleProfitCurrencyChange(e.target.value)}>
                  {currencies.map((c) => (
                    <option key={c} value={c}>{c}</option>
                  ))}
                </select>
              </div>
            </div>
            <div className="row">
              <div className="col">
                <label>Minimum Salary (RON)</label>
                <input
                  type="number"
                  value={profitSettings.minSalary}
                  onChange={(e) => {
                    const nextValue = parseFloat(e.target.value);
                    setProfitSettings((prev) => ({ ...prev, minSalary: isNaN(nextValue) ? 0 : nextValue }));
                    setProfitDirty(true);
                  }}
                />
                <label>CASS Rate</label>
                <input
                  type="number"
                  step="0.01"
                  value={profitSettings.cassRate}
                  onChange={(e) => {
                    const nextValue = parseFloat(e.target.value);
                    setProfitSettings((prev) => ({ ...prev, cassRate: isNaN(nextValue) ? 0 : nextValue }));
                    setProfitDirty(true);
                  }}
                />
              </div>
              <div className="col">
                <label>Thresholds (x Minimum Salary)</label>
                <div style={{ marginBottom: '10px' }}>
                  {(profitSettings.thresholds || [6, 12, 24]).map((t, idx) => (
                    <div key={idx}>{t}x = {(profitSettings.minSalary * t).toFixed(2)} RON</div>
                  ))}
                </div>
              </div>
            </div>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Profit ({profitCurrency})</th>
                  <th>Name</th>
                  <th>Comment</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {profitEntries.map((entry) => (
                  <tr key={entry.id}>
                    <td>
                      <input
                        type="date"
                        value={entry.date || ''}
                        onChange={(e) => updateProfitEntry(entry.id, { date: e.target.value })}
                      />
                    </td>
                    <td>
                      <input
                        type="number"
                        value={entry.amount}
                        onChange={(e) => {
                          const nextValue = parseFloat(e.target.value);
                          updateProfitEntry(entry.id, { amount: isNaN(nextValue) ? 0 : nextValue });
                        }}
                      />
                    </td>
                    <td>
                      <input
                        value={entry.name || ''}
                        onChange={(e) => updateProfitEntry(entry.id, { name: e.target.value })}
                      />
                    </td>
                    <td>
                      <input
                        value={entry.comment || ''}
                        onChange={(e) => updateProfitEntry(entry.id, { comment: e.target.value })}
                      />
                    </td>
                    <td>
                      <button className="delete-btn" onClick={() => removeProfitEntry(entry.id)}>Remove</button>
                    </td>
                  </tr>
                ))}
                {profitEntries.length === 0 && (
                  <tr>
                    <td colSpan="5" style={{ textAlign: 'center' }}>No profit entries yet.</td>
                  </tr>
                )}
              </tbody>
              </table>
            </div>
            <div style={{ display: 'flex', gap: '10px', marginTop: '10px', flexWrap: 'wrap' }}>
              <button onClick={addProfitEntry}>Add Entry</button>
              <button onClick={() => saveProfitTracker(profitEntries, profitSettings)} disabled={!profitDirty}>Save Profit Tracker</button>
            </div>
            <h3>Yearly Summary</h3>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Year</th>
                  <th>Total Profit ({profitCurrency})</th>
                  <th>CASS Due ({profitCurrency})</th>
                </tr>
              </thead>
              <tbody>
                {profitYears.map((year) => {
                  const total = profitByYear[year] || 0;
                  const profitInRon = convertAmount(total, profitCurrency, 'RON');
                  const cassDueRon = calcCassDue(profitInRon);
                  const cassDisplay = convertAmount(cassDueRon, 'RON', profitCurrency);
                  return (
                    <tr key={year}>
                      <td>{year}</td>
                      <td>{total.toFixed(2)}</td>
                      <td>{cassDisplay.toFixed(2)}</td>
                    </tr>
                  );
                })}
                {profitYears.length === 0 && (
                  <tr>
                    <td colSpan="3" style={{ textAlign: 'center' }}>No yearly data yet.</td>
                  </tr>
                )}
              </tbody>
              </table>
            </div>
          </div>
          <div className="card">
            <h2>Safe Withdrawal</h2>
            <div className="section-controls">
              <div>
                <label>Display Currency</label>
                <select value={swrCurrency} onChange={(e) => setSwrCurrency(e.target.value)}>
                  {currencies.map((c) => (
                    <option key={c} value={c}>{c}</option>
                  ))}
                </select>
              </div>
            </div>
            <div style={{ marginBottom: '10px' }}>
              <div><strong>Portfolio value:</strong> {swrCurrentValue.toFixed(2)} {swrCurrency}</div>
              <div><strong>Value + Retirement:</strong> {portfolioPlusRetirement.toFixed(2)} {swrCurrency}</div>
            </div>
            <div className="table-wrapper">
              <table>
              <thead>
                <tr>
                  <th>Rate</th>
                  <th>Annual ({swrCurrency})</th>
                  <th>Monthly ({swrCurrency})</th>
                  <th>Annual (Value + Retirement)</th>
                  <th>Monthly (Value + Retirement)</th>
                </tr>
              </thead>
              <tbody>
                {[0.04, 0.05, 0.06].map((rate) => {
                  const annual = swrCurrentValue * rate;
                  const annualPlus = portfolioPlusRetirement * rate;
                  return (
                    <tr key={rate}>
                      <td>{(rate * 100).toFixed(0)}%</td>
                      <td>{annual.toFixed(2)}</td>
                      <td>{(annual / 12).toFixed(2)}</td>
                      <td>{annualPlus.toFixed(2)}</td>
                      <td>{(annualPlus / 12).toFixed(2)}</td>
                    </tr>
                  );
                })}
              </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
